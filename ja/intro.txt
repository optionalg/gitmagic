== まえがき ==

この章ではある面白い比喩を使ってバージョン管理について説明しようと思う。真面目な説明が読みたい場合は http://ja.wikipedia.org/wiki/バージョン管理システム [Wikipedia のバージョン管理システムのエントリ] を見て欲しい。

=== 働くことは遊ぶこと ===

僕は子供の頃から、ほとんどいつもコンピュータゲームをプレイしてきた。それに比べると、バージョン管理システムを使うようになったのは大人になってからのとても短い間だ。こう思うのは僕だけじゃないと思うんだけど、コンピュータゲームとバージョン管理システムとの比較で、それらのコンセプトを理解し説明するのがより簡単になると思う。

コードやドキュメントを書くことを、ゲームをプレイすることに例えてみよう。たくさんの進捗があったあとにはその成果を保存したいと思うだろう。そのためには、信頼できるエディタの「保存」ボタンを押すだろうと思う。

でも、これは古いバージョンを上書きしてしまう。セーブスロットが一つしか無い昔のゲームみたいだ。それらのゲームでも、もちろんセーブすることは出来る。だけど、昔のセーブ箇所に戻ることはできなくて、これは本当に残念なことだった。ゲームの中にとても魅力的な箇所があっても、そこに戻ることができないのだから。そして悪いことに、一つしか無いそのセーブデータがゲームをクリアできないもの(訳註：詰んだ場合)だったとしたら、もう一度最初からやり直さないといけなかった。

=== バージョン管理 ===

コンピュータでファイルを編集するとき、過去のバージョンを残したいときには「名前をつけて保存..」 を選択して開いているものとは別のファイルに保存したり、ファイルを変更する前にコピーをどこかにとることができる。ディスクスペースを節約するために、コピーを圧縮することもできる。これは、原始的な手作業で行われるバージョン管理だ。コンピュータゲームははるか以前にこの点を改善し、今では自動的にタイムスタンプの付けられる複数のセーブスロットを備えている。

もう少し厳しい問題を考えてみよう。あるプロジェクトやウェブサイトを構成するいくつかの関連するファイルがあるとしよう。この場合、古いバージョンを取っておきたい場合にはディレクトリ全部をアーカイブする必要がある。多くのバージョンを手作業で管理するのは不便だし、すぐに背負いきれない物となってしまう。

いくつかのコンピュータゲームでは、セーブされたデータはまさにファイルでいっぱいのディレクトリで構成されている。これらのゲームではセーブデータの複雑な内部はユーザーから隠され、便利なインターフェイスで管理することができる。

バージョン管理システムも同じようなもので、ディレクトリを管理するための便利なインターフェイスを提供してくれる。ディレクトリの状態を何個も頻繁に保存して置けるし、あとからいつでもその保存されたものを取り出すことができる。コンピュータゲームと異なるのは、バージョン管理システムはディスクスペースの節約にも長けているということだ。普通は異なるバージョン間で２，３個のファイルが変更されるだけだ。新しいファイルを全て保存するのではなく、古いバージョンとの差分だけを保存することで、ディスクスペースの節約を実現している。

=== 分散管理 ===

とても難解なコンピュータゲームをイメージしてみよう。クリアするのがとても難しくて、世界中の経験豊富なゲーマー達が協力してセーブデータを共有しあってクリアを目指すことにした。"やり込み"は現実の一例だ。一つのゲームの異なるレベルを専門にするプレイヤー達が協力して、驚くべき結果を生み出している。


他のプレイヤーのセーブデータをとってきたり、新しいデータをアップロードするために、あなたならどんなシステムを作るかな？

その昔には、全てのプロジェクトでは中央管理型のバージョン管理システムが使われていた。ある場所にあるサーバが全てのセーブデータを保存していて、個々のプレーヤーは最近のセーブデータをせいぜい２，３個手元のマシンに保存していただけだ。プレーヤーがゲームを進めたいと思ったら、最新のセーブデータを中央サーバからダウンロードする。そして、しばらくゲームを進めてセーブして、他の人達がそのデータを使えるように中央サーバにアップロードする。

もし、プレーヤーが古いセーブデータを使いたい場合はどうするか？例えば、誰かがレベル３の目標を達成し忘れていたなんて理由で、今のセーブデータが"詰んだ"状態にあるときに、まだゲームがクリア可能な最新のバージョンを探したい時や、個々のプレーヤーがどの位の事を成し遂げたのか知りたくて古い二つのバージョンを比較するような時にだ。

古いリビジョンを見たいというのにはいろいろな理由があるけど、やるべき事は一つだ。中央サーバから古いバージョンを取り出さないといけない。参照したいセーブデータが増えれば、その分中央サーバとの通信が増える事になる。

Git のような新世代のバージョン管理システムは分散バージョン管理システム (Distributed Version Control System、以後 DVCS) と呼ばれていて、中央管理型のバージョン管理システムの一般化だと考えることができる。プレーヤーがメインサーバから一度ダウンロードを行えば、最新の物だけではなく全てのセーブデータのバージョンが手に入る。それらは中央サーバのミラーのようなものだ。

プロジェクトが大量の履歴を持っているとき、最初の複製には時間がかかるかもしれない。でも、開発の長い時間を考えればそれは大きな問題じゃない。古いバージョンのデータが欲しい時に、中央サーバとの通信が必要ないのをすぐに利点だと感じられるだろう。

=== 愚かな迷信 ===

よくある誤解の一つが、DVCS はオフィシャルの中央リポジトリが必要なプロジェクトには不向きだというものだ。でも、本物以外の物が本物にはなれないし、誰かの写真をとっても魂が吸い取られるわけではない。同様に、マスタリポジトリを複製できても、マスタリポジトリの重要性が低くなるというわけではないんだ。

最初に思い浮かぶ良い例えは、中央管理型が出来ることは全て、良くデザインされたDVCSならもっとうまくやれるということだ。ネットワーク上のリソースはローカルのものよりも高価なんだ。ただ、後で分散管理システムの短所についても見ようと思う。このような大まかな比較はあまり正確ではない。

小さなプロジェクトではDVCSが提供する機能の単にいくつかを使うに過ぎないかもしれない。けれど、小さなプロジェクトでしか使えないようなシステムを使うのは、ローマ数字を使って少数を含む計算を行うことに近い。

さらに、プロジェクトはあなたの想像を超えて大きくなるかもしれない。プロジェクトの最初からGitを使うのはボトルを開けることしかしないのに、スイスアーミーナイフを持ち運ぶようなものかもしれない。ある日、どうしてもねじ回しが必要になったとき、スイスアーミーナイフを持っていたことに感謝するだろう。

=== マージの衝突 ===

このトピックを語るには、コンピュータゲームのたとえではとても追いつかない。代わりに、ドキュメントの編集について考えてみよう。

アリスがファイルの最初の行に何かを書いたとする。その後、ボブが彼のコピーの最後に一行を付け加えた。彼らはふたりともその変更をアップロードした。ほとんどのシステムでは自動的に合理的な処理が選択される。ここでは、彼らの変更を受け入れマージし、アリスとボブ変更はどちらも適用される。

それでは、アリスとボブが同じ行にそれぞれ違う変更を施したとしよう。こうなると人間の判断なしでは前に進めない。２番目にアップロードを行った人は _merge conflict_ を通知され、二つの変更のどちらを選ぶか、または行を完全に変更してしまうかを選ばないといけない。

もっと複雑な状況も起こりうる。バージョン管理システムは簡単なケースを扱うが、難しいケースを人に委ねる。普通は、その動作を設定で変更できる。

